# импорт библиотек
import csv
import pickle

data = []
data_pkl = []
# файл в котором будем хранить преобразованый тип из словаря
data_set = 'temp.pkl'

def recognize_type(value):
    """
    Распознование простейших типов данных.
    """
    # Список типов которые будем распозновать
    list_type = [int, str, bool]
    # Перебираем список типов для проверки
    for _type in list_type:
        # начало области обработки иссключения
        try:
            # пробуем преобразовать значение value к типу из списка тип в перемонной _type
            rez = _type(value)
        # если возникает иссключительная ситуация то ниже она будет обрабатываться
        except ValueError:
            # если ошибка то берем следуюший тип
            continue
        # не было иссключительной ситуации преобразование удачное
        else:
            # возвращаем преобразованный значение и его тип
            return rez, _type

def load_table(file):
    """
    Загрузка табличных данных из CSV файла во внутренее представление.
    """
    # переменная для сохранение значение в словаре
    table = {}
    # переменнная для сохранение заголовка из ЦСВ файла
    head_type = {}
    # начало блока обработки иссключительной ситуации
    try:
        # открываем файл для обработки
        with open(file) as f:
            # получаем данне в виде словаря разделитель ;
            reader = csv.DictReader(f, delimiter=';')
            # получаем название полей
            list_key = reader.fieldnames
            # переменная словаря для хранения данных из ЦСВ
            table['data'] = []
            # получаем строчки для ЦСВ
            for row in reader:
                # ищем первую строку для сохранения заголовка
                if not head_type:
                    # тут храниться заголовок
                    head_type = {}
                    # перебираем название полей
                    for key in list_key:
                        # получаем название поля и пытаемся расспознать его тип по данные из ЦСВ - row[key]
                        (r, t) = recognize_type(row[key])
                        # сохраняем название поля и его тип в переменной
                        head_type[key] = t
                    # перебрали все и формируем итоговый справочник для дальнейшей обработки
                    table['head'] = head_type
                # добавление данные из ЦСВ в справочник для дальнейшей обработки
                table['data'].append(row)
    # Обработка иссключительной ситуации при отсутствие файла
    except FileNotFoundError as err:
        #  печатаем
        print(f'ERROR file not FOUND. {err}')
        # завершаем программу
        exit()
    # полученные данные для дальнейшей обработки преобразуем во внутренний формат
    s_data = serializeed_data(table)
    # сохраняем во временный файл справочник с данными при следующей обработке будем брать данные из ыременного файла
    save_picle(s_data)


def save_table(file):
    """
    Сохранение данных (внутреннее представление) в CSV файл.
    """
    # берем из временного файла данные во внутреннем формате
    data_pkl = load_picle()
    # преобразуем из внутреннего формат в формат для обработки
    data = deserializeed_data(data_pkl)
    # сохраняем во файл данне будут в ЦСВ
    with open(file, 'w') as f:
        # подготавливаем справочник для сохранения разделитель ; и определяем заголовок для ЦСВ файла
        write = csv.DictWriter(f, delimiter=';', fieldnames=list(data['head'].keys()))
        # пишем в файл все что сформировали на предыдущем операторе это заголовок
        write.writeheader()
        # передираем данные из списка построчно
        for row in data['data']:
            # пишем строчку с данными в файл
            write.writerow(row)

def serializeed_data(data):
    # преобразуем во внутренный формат
    return pickle.dumps(data)

def deserializeed_data(data_pkl):
    # преобразуем из внутреннего формата в формат справочника для обработки
    try:
        return pickle.loads(data_pkl)
    # обработка иссключения ошибка типов
    except TypeError as err:
        # печать сообщения об ошибке
        print(f'ERROR: {err}')
        # завершение программы
        exit()

def save_picle(object):
    # сохраниение данных во внутреннем формате в файл
    with open(data_set, 'wb') as f:
        pickle.dump(object, f)

def load_picle():
    # загрузка из фала данных во внутреннем формате
    # блок обработки иссключений
    try:
        # берем данные из временного файла
        with open(data_set, 'rb') as f:
            # получение данных из файла
            data = pickle.load(f)
    # обработка иссключений при отсутствие файла
    except FileNotFoundError as err:
        # печать ошибки
        print(f'ERROR file not FOUND. {err}')
        # завершение программы при ошибке
        exit()
    # возврат данных из файла
    return data

def print_table():
    """
    вывод таблицы на печать.
    """
    # получение данных во внутреннем формате
    data_pkl = load_picle()
    # преобразование из внутреннего формата в формат справочника для обработки
    data = deserializeed_data(data_pkl)
    # перебираем данне заголовка и типов данных ПЕЧАТАЕМ сначало заголовок
    for (key, value) in data['head'].items():
        print(key, value, end=' ')
    print()
    # печатаем данные из словаря
    for data_row in data['data']:
        # перебираем название столбц и значение
        for (key, value) in data['head'].items():
            print(data_row[key], end=' ')
        print()

def get_rows_by_number(): #start, [stop], copy_table=False):
    """
    получение таблицы из одной строки или из строк из интервала по номеру строки.
    Функция либо копирует исходные данные, либо создает новое представление таблицы, работающее с исходным набором данных (copy_table=False),
    таким образом изменения, внесенные через это представления будут наблюдаться и в исходной таблице.
    """
    pass

def get_rows_by_index(): #val1,  , copy_table=False):
    """
     получение новой таблицы из одной строки или из строк со значениями в первом столбце, совпадающими с переданными аргументами val1, … , valN.
    Функция либо копирует исходные данные, либо создает новое представление таблицы, работающее с исходным набором данных (copy_table=False),
    таким образом изменения, внесенные через это представления будут наблюдаться и в исходной таблице.
    """
    pass

def get_column_types(by_number=True):
    """
    получение словаря вида столбец:тип_значений.
    Тип значения: int, float, bool, str (по умолчанию для всех столбцов).
    Параметр by_number определяет вид значения столбец – целочисленный индекс столбца или его строковое представление.
    """
    pass

def set_column_types(types_dict, by_number=True):
    """
    задание словаря вида столбец: тип_значений.
    Тип значения: int, float, bool, str (по умолчанию для всех столбцов).
    Параметр by_number определяет вид значения столбец – целочисленный индекс столбца или его строковое представление.
    """
    pass

def get_values(column=0):
    """
    получение списка значений (типизированных согласно типу столбца) таблицы из столбца либо по номеру столбца
    (целое число, значение по умолчанию 0, либо по имени столбца)
    """
    pass

def get_value(column=0):
    """
     получение списка значений (типизированных согласно типу столбца) таблицы из столбца либо по номеру столбца
    (целое число, значение по умолчанию 0, либо по имени столбца)
    """
    pass

def set_values(values=[], column=0):
    """
    аналог get_values(column=0) для представления таблицы с одной строкой, возвращает не список,
    а одно значение (типизированное согласно типу столбца).
    """
    # получает данные из временного фйла во внутреннем формате
    data_pkl = load_picle()
    # преобразовать из внутреннего формата в формат словаря для обработки
    data = deserializeed_data(data_pkl)
    # получаем список заголовков полей из словаря
    _head = list(data['head'])
    # получает типы столбцов из словаря
    _type = list(data['head'].values())
    _column = 0
    # проверяем как передаем либо № столбца либо по названию столбца
    if not isinstance(column, int):
        # перебираем названия столбцов
        for name_column in _head:
            # нашли столбец который должны обработать ищем его номер в списке
            if column != name_column:
                _column += 1
            else:
                break
    else:
        # номер столбца если он определен цифрой
        _column = column
    # пробегаем по столбцу и меняем на значения из списка
    for i in range(len(values)):
        # обработка иссключений
        try:
            # меняем значения в в определенном столбце
            data['data'][i][_head[_column]] = _type[_column](values[i])
        except ValueError as err:
            print(f'ERROR types for filed. {err}')
    # преобразуем во внутренний формат
    data_pkl = serializeed_data(data)
    # сохраняем во временный формат
    save_picle(data_pkl)

def set_value(column=0):
    """
    задание списка значений values для столбца таблицы (типизированных согласно типу столбца) либо по номеру столбца
    (целое число, значение по умолчанию 0, либо по имени столбца).
    """
    pass

# основная часть программы которая запускаети все обработкт.
# все что выше можно вынести в отдельный файл и подключать через import
file = 'test.csv'
file_new = 'test_new.csv'
file_pkl = 'test.pkl'

load_table(file)
print_table()

# меняем данные в столбце
set_values([11, 12, 13, 14], column='ID')

# тоже пытаемся менять возникает иссключительная ситуация т.к. столбец ID это целое число, а мы передаем сторки
set_values(['Кочнев Вадим', 'Ульянов Константин', 'Семенов Алексей', 'Петров Дмитрй'], column='ID')

save_table(file_new)